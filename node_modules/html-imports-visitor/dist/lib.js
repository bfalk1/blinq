'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var fs = require('fs');
var parse5 = require('parse5');
var dom5 = require('dom5');

const isAbsoluteRegex = new RegExp("^([a-z]+://|//)", "i");

const resolve$1 = (basePath, href) => path.resolve(path.dirname(basePath), href);
const isLocal = (href) => href && !isAbsoluteRegex.test(href);
const load = (file) => fs.readFileSync(file, "utf8");
const fileExists = (path$$1) => fs.existsSync(path$$1);

const predicates$1 = dom5.predicates;

/**
 * Traverse the spanning tree of the HTML Imports graph starting from a given location
 *
 *
 * The linking structure of import link lists forms a directed graph.
 * Each node of the graph is a document and its edge is a link.
 * Branches are intended to form a spanning tree of the graph.
 * This tree gives the deterministic order of the script execution.
 * @see https://www.w3.org/TR/html-imports/#import-dependent
 *
 * @param {Object} visitor A visitor object that will be used for traversal
 * @param {string} path The path to start from
 * @param {Predicate} predicate A predicate to select HTML elements to be visited
 * @param {Object} [importMap] The set of traversed imports
 * @param {HTMLLinkElement} [link] The current <link rel="import"> element
 * @return {void}
 */
const traverse = (visitor, path$$1, predicate, importMap, link) => {
  if ( importMap === void 0 ) importMap = {};
  if ( link === void 0 ) link = null;


  // If location is already in the import map
  // OR <link rel="import"> has been removed by visitor
  // then STOP
  if (importMap[path$$1] || link && !link.parentNode) {
    return
  }

  // The imported document
  const document = parse5.parse(load(path$$1));
  importMap[path$$1] = document;

  visitor.enter(document, { path: path$$1, link });

  const elements = dom5.queryAll(document, predicate);
  let index = 0;

  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];

    const linkHref = element.tagName === "link" &&
      String(dom5.getAttribute(element, "rel")).toLowerCase() === "import" &&
      dom5.getAttribute(element, "href");

    if (linkHref) {
      const isLocal$$1 = isLocal(linkHref);
      const location = isLocal$$1 ? resolve$1(path$$1, linkHref) : linkHref;
      const isExists = isLocal$$1 && fileExists(location);
      visitor.import(element, { path: path$$1, location, isLocal: isLocal$$1, isExists });
      // Exclude remote locations and non-existing files
      if (isExists) {
        // Recursively traverse any found import locations
        traverse(visitor, location, predicate, importMap, element);
      }
    } else {
      visitor.visit(element, { path: path$$1, index });
      index++;
    }
  }
};


var AND = predicates$1.AND;
var OR = predicates$1.OR;
var hasTagName = predicates$1.hasTagName;
var hasAttrValue = predicates$1.hasAttrValue;
var hasAttr = predicates$1.hasAttr;

// Query selector for link[rel=import]
const htmlImportPredicate = AND( // eslint-disable-line new-cap
    hasTagName("link"),
    hasAttrValue("rel", "import"),
    hasAttr("href")
);

const noopVisitor = {
  import() {},
  enter() {},
  visit() {}
};

class VisitorHelper {

  /**
   * Constructor
   *
   * @param {Object} visitor A visitor object that will be used for traversal
   * @param {(Predicate|Predicate[])} [predicatesList] An array of predicates to select elements
   */
  constructor(visitor, predicatesList) {
    if (predicatesList) {
      this.predicate = predicatesList instanceof Array ?
        OR.apply(void 0, [ htmlImportPredicate ].concat( predicatesList )) : // eslint-disable-line new-cap
        OR(htmlImportPredicate, predicatesList); // eslint-disable-line new-cap
    } else {
      this.predicate = htmlImportPredicate;
    }
    this.visitor = Object.assign({}, noopVisitor, visitor);
    this.importMap = {};
  }

  /**
   * Traverse but not visit the spanning tree of the HTML Imports graph from a given entry
   *
   * Traversed branches will be omited in following traversals.
   * If called prior to enter(), branches already traversed by omit() will be not visited again.
   *
   * @param {string} entry An HTML file path
   * @return {VisitorHelper} This
   */
  omit(entry) {
    traverse(noopVisitor, path.resolve(entry), htmlImportPredicate, this.importMap);
    return this
  }

  /**
   * Traverse and visit the spanning tree of the HTML Imports graph from a given entry
   *
   * @param {string} entry An HTML file path
   * @return {VisitorHelper} This
   */
  enter(entry) {
    traverse(this.visitor, path.resolve(entry), this.predicate, this.importMap);
    return this
  }

}

exports.resolve = resolve$1;
exports.isLocal = isLocal;
exports.load = load;
exports.fileExists = fileExists;
exports.predicates = predicates$1;
exports.VisitorHelper = VisitorHelper;
//# sourceMappingURL=lib.js.map
