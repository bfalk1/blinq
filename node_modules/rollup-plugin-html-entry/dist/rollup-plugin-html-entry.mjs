import { readdirSync, mkdirSync, writeFile } from 'fs';
import { dirname, resolve, relative } from 'path';
import { sync } from 'matched';
import { VisitorHelper, predicates, isLocal, resolve as resolve$1 } from 'html-imports-visitor';
import { serialize } from 'parse5';
import { remove, getAttribute, getTextContent } from 'dom5';

var mkdir = (path) => {
  try {
    readdirSync(path);
  } catch (err) {
    mkdir(dirname(path));
    mkdirSync(path);
  }
};

var writeFileEx = (path, doc) => (res, rej) => {
  writeFile(path, serialize(doc), (err) => err ? rej(err) : res());
};

var mkdirEx = (path) => (res, rej) => {
  try {
    mkdir(path);
    res();
  } catch (err) {
    rej(err);
  }
};

var writeHtmls = (htmls, destPath) => {

  var executors = {};
  for (var filepath in htmls) {
    var destFilepath = resolve(destPath, relative(process.cwd(), filepath));
    var destDirpath = dirname(destFilepath);
    var ex = writeFileEx(destFilepath, htmls[filepath]);
    if (executors[destDirpath]) {
      executors[destDirpath].push(ex);
    } else {
      executors[destDirpath] = [ex];
    }
  }

  return Promise.all(
    Object.keys(executors).map(
      (path) => new Promise(mkdirEx(path)).then(
        Promise.all(
          executors[path].map((ex) => new Promise(ex))
        )
      )
    )
  )
};

var entry = "\0rollup-plugin-html-entry:entry-point";

var index = (config) => {
  var include = "**/*.html";
  var exclude = [];
  var external = [];
  var exporter = (path) => `export * from ${JSON.stringify(path)};`;
  var output = false;

  var configure = (options) => {
    if (typeof options === "string") {
      include = [options];
    } else if (Array.isArray(options)) {
      include = options;
    } else {
      include = options.include || [];
      exclude = options.exclude || [];
      external = options.external || [];
      if (options.exports === false) {
        exporter = (path) => `import ${JSON.stringify(path)};`;
      }
    }

    if (options.output) {
      output = options.output;
    }
  };

  if (config) {
    configure(config);
  }

  var realPaths;
  var virtualPaths;
  var pathsList;
  var htmls;
  var excludeMap;

  var visitor = {

    import(link, ref) {
      var location = ref.location;

      if (excludeMap[location]) {
        // remove <link rel="import"> and avoid entering the doc
        remove(link);
      }
    },

    enter(document, ref) {
      var path = ref.path;

      htmls[path] = document;
    },

    visit(element, ref) {
      var path = ref.path;
      var index = ref.index;

      realPaths[path] = true;
      var src = getAttribute(element, "src");
      if (src) {
        if (isLocal(src)) {
          pathsList.push(resolve$1(path, src));
          if (output) {
            remove(element);
          }
        }
      } else {
        // (todo) should avoid possibile collision against real paths
        var virtualPath = `${path}_${index}.js`;
        pathsList.push(virtualPath);
        virtualPaths[virtualPath] = getTextContent(element);
        if (output) {
          remove(element);
        }
      }
    }
  };

  var analyze = () => {

    // Reset
    realPaths = {};
    virtualPaths = {};
    pathsList = [];
    htmls = {};
    excludeMap = {};

    var helper = new VisitorHelper(visitor, predicates.hasTagName("script"));

    if (exclude.length) {
      var excluded = sync(exclude, { realpath: true });
      for (var i in excluded) {
        excludeMap[excluded[i]] = true;
      }
    }

    if (external.length) {
      var omitted = sync(
        external,
        { realpath: true }
      );
      for (var i$1 in omitted) {
        helper.omit(omitted[i$1]);
      }
    }

    if (include.length) {
      var included = sync(
        include.concat(exclude.map((pattern) => `!${pattern}`))
               .concat(external.map((pattern) => `!${pattern}`)),
        { realpath: true }
      );
      for (var i$2 in included) {
        helper.enter(included[i$2]);
      }
    }
  };

  return {
    options(options) {
      if (options.input && options.input !== entry) {
        configure(options.input);
      }
      options.input = entry;
      analyze();
    },

    resolveId(id) {
      if (id === entry) {
        return entry
      }

      if (id in virtualPaths) {
        return id
      }
    },

    load(id) {
      if (id === entry) {
        if (!pathsList.length) {
          return Promise.resolve("")
        }
        return new Promise(
          (res) => res(pathsList.map(exporter).join("\n"))
        )
      }

      if (id in virtualPaths) {
        return virtualPaths[id]
      }
    },

    generateBundle() {
      if (output) {
        return writeHtmls(htmls, output)
      }
    }
  }

};

export default index;
